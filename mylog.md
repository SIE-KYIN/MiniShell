# 3/19(토) 2:40

- 규진이코드에서 컴파일시 메모리릭 난다.(fsanitaze)
- >pwd, >quit (종료안됨) , >quit(종료됨) 의 동작을 이해할 수 없다.
	규진이와 점검하면서도 이상함을 느낀점이 있는데,,,
	원래라면 자식프로세스가 할일을 다하고 종료되고, 부모프로세스는 그때까지 대기해야 하는데
	자식프로세스가 할일을 끝내고 부모프로세스의 동작을 다시 수행하는 것 같다....
	exec이후에 자식프로세스가 살아서 printf를 수행하는 것을 보고 확신했다.
	자식프로세스가 왜 죽지 않는지 알아봐야 겠다.[exit을 안해주어서 수정함 처리완료!]

- 빌트인 함수의 경우 규진이가 잘라놓은 env_list를 사용하기 용이하지만,
	그렇지 않은 함수를 사용할땐 env 포인터배열을 그대로 사용하는 게 유리하다.
	그렇다면 둘다 넘겨주어야 하나...?
	둘다 넘기던지 아니면 둘을 모두가진 구조체를 선언하여 관리할지 생각해봐야 겠다.
	[env_list로 관리하되, exec시에는 list를 char**로 변환하여 인자로 넘겨줄것.]
# 3/19(토) 2:55

- 일단 빌트인함수의 경우 exit을 시켜주지 않아 자식이 살아있어서 pwd, quit, quit이 가능했다.
	빌트인외 함수는 execve함수 밑으로는 실행되지 않는 것 같지만 규진이와 검사했을때
	execve행 이후의 free가 처리되는 것을 확인한 적이 있어 다시한번 체크해야겠다.
	그리고 계속되는 테스트에 죽지않고 살아있는 미니쉘 프로세스가 많아서 한번에 죽여버릴 스크립트를짰다
	ps | awk '{ print "kill -9", $1 }' | sh -v
	kill -9 `ps -ef | grep minishell | awk '{print $2}'`

- quit입력이외에 ctrl z 같은 시그널로 종료할 경우,,,, 프로세스가 죽지않아!

- leak 검사를 해보는데 leak이 너무 많다. 그리고 filepath는 free되지 않는 것 같다.

# 3/19(토) 3:12 자기 전 내일해야할 투두리스트

- 규진이 코드에서 leak을 잡고 내거에서도 filepath가 leak나지 않게 처리할 것.
- 쉘이 exit을 통해 꺼졌을때 다시 자동으로 켜줘야 한다고 들은것 같은데..
	그리고 애초에 ./minishell은 미니쉘 프로세스를 생성해주는 역할을 하니 그것도 메인에 넣어야함.
- env_list와 env를 둘다 사용할지 고르자.[처리완료]
- read_line -> parse_line -> execute 코드가독성이 너무 떨어짐.... 전체구조를 다시 고려해볼것.[처리완료]
- parse_line에서 strtok대신 사용할 수 있는 함수를 생각해볼것. split 시험본 버전으로하면 좋을듯.[처리완료]

# 3/19(토) 13:14

- 규진이 코드에서 릭나는건 모두 잡았다.[처리완료]
	1. linkedlist에서 addnode를 할때 추가하는 노드의 next필드를 NULL로 초기화하지않고 쓰레기값이 들어가서 다른 노드를 가리키는 것처럼 여겨진다.
	2. ft_strndup함수에서 복사를 수행하는 while문 조건식이 잘못되었다.


# 3/21(월) 18:25
일반 출력 리다이렉션(>)의 경우,
파일에 출력내용을 덮어쓴다.

#define STDOUT_SIMPLE O_RDWR|O_CREAT|O_EXCL
->파일이 존재하지 않을경우 open에 실패한다...?

추가 출력 리다이렉션(>>)의 경우,
파일의 뒷부분에 추가한다.

https://badayak.com/entry/C%EC%96%B8%EC%96%B4-%ED%8C%8C%EC%9D%BC-%EC%97%B4%EA%B8%B0-%ED%95%A8%EC%88%98-open
를 참고하여 파일모드를 적용하였다.

# 3/21(월) 18:56

출력 리다이렉션인 >, >>를 구현했다.
단 한 줄에 여러 리다이렉션이 있을 경우를 아직 해결하지 못했다.

입력 리다이렉션도 구현해보자.

그리고 빌트인함수를 구현할때 어떻게 최신화된 환경변수리스트를 들고있을지에 대한 고민이 생겼다.
터미널에 대한 정보를 모은 전역변수 하나를 선언하면 프로젝트가 훨씬 쉬워질 것 같다.
전역변수에 환경변수 리스트를 넣어두면 최신화하기도 편하고 접근하기도 용이할 것 같다.

env,export차이는?
https://wikidocs.net/72712
https://m.blog.naver.com/whdgml1996/222036754903


좋은 글
https://velog.io/@enter/Linux-Shell-%EA%B5%AC%ED%98%84-1-%EC%BB%A4%EB%A7%A8%EB%93%9C%EC%99%80-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98

# 3/23(화) 구현한 부분 정리

- tree자료구조와 외장,내장함수를 실행하는 부분을 합침.
	- makefile구조 구성완료.
	- 리다이렉션(>,>>)까지 구현완료.

- 수정해야할 점.
	- 트리노드의 멤버변수로 char *command, char *argument로 나뉘어있는 것을 char *arg[]로
	합쳐서 멤버변수의 수를 줄이고 exec하기 용이하게 만든다. arg의 마지막 원소는 NULL이어야 한다.[규진이가완료]
	- redir에서 "<", "<<"를 strcmp로 구분하고있는데 허용함수가 아니라서 다른 방법을 찾아야 한다.
	참고로 ft_strncmp로는 구분할 수 없다. ft_strncmp를 이용하여 ft_strcmp를 만들어볼까?[처리완료]
	- 단일 명령어를 수행하지 못하고 SEGFAULT가 뜬다.[규진이가완료]

# 3/24(목) 16:20

- parse_line함수를 사용할 필요가 없어졌다. 파싱의 결과를 tree에서 가지고 있고
 tree를 순회하며 명령어를 실행하면 되기 때문이다.
 parse_line은 현재 사용하지 않고 사용하던 위치에 pre_traverse함수를 넣어두었다.

- 트리에서 2개 이상의 리다이렉션이 있을때 어떤 순서로 순회를 하고 처리해야 할지 고민중!
 생각해보니 1개의 파이프라인에 대한 처리를 한 후에 결정하는 것이 나을 것 걑다.

- [?]exec전에 malloc한 녀석들은 어떻게 free해줘야 하지?

# 3/25(금)

- [이해완료]ls | cat 을 입력하면
	ls의 결과가 cat의 인자가 된다.
	그런데 ls | cat a.txt를 하면
	cat a.txt가 실행되고 ls의 결과는 출력되지 않는다.
	cat a.txt b.txt를 수행해보니
	a.txt와 b.txt가 각각 출력되었다.
	즉 cat은 가지고 있는 인자들에 대해 모두 cat을 해주었다는 얘기다.
	그런데 왜 ls | cat a.txt에서 ls의 결과가 출력되지 않았을까?
	그건 파이프에서 뒷 프로세스가 이미 실행인자를 가지고 있다면
	파이프를 통해 데이터를 읽지 않는 것이 아닐까?
	그렇지만 cat /etc/passwd | grep mail 같은 경우에는
	뒷 프로세스가 실행인자를 가지고 있지만 앞 프로세스의 결과가 무시되지 않는다....ㅜ
=>4/2
	ls의 결과는 파이프에 담겨있으며 cat이 표준입력을 read하면 나오게 된다.
	그러나 cat은 이미 실행인자를 가지고 있으므로 표준입력을 받을 필요가 없다.
	그래서 ls의 결과가 나오지 않는 것이다.
	cat /etc/passwd | grep mail의 경우
	grep 명령어는 grep하는 대상이 표준입력으로 들어오는 데이터이기 때문에
	언제나 표준입력을 요구하는 명령어라고 볼 수 있다. 그래서 앞결과가 무시되지않는다.

- 현재 코드는 redirection 노드까지만 재귀를 하였다. 리프노드로는 재귀하지 않았다.
그러나 이럴 경우 단일 명령어에 대한 실행을 할 수 없고, 파이프및 리다이렉션의 처리와 그 아래에 있는 명령어노드를 실행하는 것을 하나의 함수에서 실행하기 때문에 깔끔하지 않다.
즉, 한번의 순회에서는 루트노드에 해당하는 동작만 해주는 것이 옳다.
ex) 파이프순회중에는 pipe함수 호출, 리다이렉션순회중에는 우측노드에 해당하는 파일open후 입출력수정,
명령어순회중에는 명령어 실행.

- 규진이한테 잘못말한거 리다이렉션 왼쪽은 무조건 명령어 오른쪽은 파일.

# 3/26(토)

- cat < a.txt < b.txt 수행시
bash는 b.txt만 입력되고
zsh는 a.txt, b.txt가 차례로 입력된다.[이해완료]

- 미니쉘 exit수행시 껏다 다시켜지는 기능[처리완료]

- 자꾸 틀려서 써둡니다.[기록완료]
// exec해줄때 실행인자의 마지막에 null이 들어가야 합니다.
	if (ft_strncmp(root->left_child->argument, "", 1) == 0)
		arg[1] = NULL;

# 3/27(일)

- sort명령어가 /bin/에 존재하지 않는다. 실행시 모든 PATH를 뒤지는 로직이 필요하다[완료]
- 빈입력을 넣으면 SEGFAULT[처리완료]
- ls | pwd 수행시 쉘이 이상해진다. 프롬프트가 개행처리되지않고 한줄더 출력된다.
	혹시 ls의 결과를 pwd가 쓰지않아서 버퍼에 남아있는 것이 아닐까? 버퍼를 비우는 함수를 써야하나?[처리완료]
	ps 해보니 좀비프로세스들이 남아있다. 찾아보자. [처리완료]

# 리다이렉션 ======================================================

## 리다이렉션 기본 동작

### 리다이렉션 출력
출력파일이 존재하지 않아도 됨. 미존재시 새로 생성해줌.

### 리다이렉션 입력
입력파일이 존재해야함. 미존재시 에러를 출력하고 동작을 멈춤.

실행되는 명령어에서 표준입력을 필요로 하지 않는 경우에, 입력값을 받지 않을 수 있음.
ex) cat명령어를 인자없이 실행하면 표준입력을 읽어오지만, 인자값이 들어오면 표준입력을
	읽으려 하지 않는다.
그렇지만 명령어에서 표준입력을 읽어오는지와는 별개로, 존재하지 않는 파일을 리다이렉션 입력해버리면 오류를 출력하고 동작을 멈춘다.

## 리다이렉션 중첩의 모든 경우의 수.
1. 출력리다이렉션이 반복될때. 맨 뒤에있는 파일에만 출력된다.[처리완료]
단, a파일은 생성되야함.
ls > a.txt > b.txt

2. 입력리다이렉션이 반복될때. 맨 뒤에있는 파일만 적용한다.[처리완료]
단, a파일은 존재해야함.
cat < a.txt < b.txt
aaaa
bbbb

3. 출력 -> 입력 리다이렉션시, 출력은 성공하지만 입력은 무시됨.[처리완료]
단, b파일은 존재해야함.
ls > a.txt < b.txt

4. 입력 -> 출력 리다이렉션시, 모두 성공한다.[처리완료]
cat < a.txt > b.txt

## 리다이렉션 중첩 팁

같은 리다이렉션이 중복되면, 뒤에나온 것만 적용된다.
그렇지만 앞에나온 리다이렉션이 가르키는 파일을 open은 한다.

================================================================

- nerdtree

# minishell에서 minishell을 키면 시그널처리가 중첩된다고 함....

# 반례=========================================================

## 1 입력시 리다이렉션 위치 조정[미해결]
bash$ cat < a.txt b.txt c.txt
im b
im c

/Users/gshim/Study/minishell ▶️  cat < a.txt b.txt c.txt
im a

=>원인: 리다이렉션 연산은 연산자(<,<<,>,>>)와 피연산자 하나로 이루어짐.
실제로 위 명령어들은
cat b.txt c.txt < a.txt와 같은 명령어이다.
cat은 입력된 인자가있으므로 표준입력(a.txt)으로부터 읽지않는다.
=>해결법
	리다이렉션연산자, 리다이렉션 피연산자를 위치에 상관없이 따로 파싱해둔다.

## 2 파이프라인 연속[미해결]
bash$ cat a.txt | cat b.txt | cat c.txt
im b
minishell$ cat a.txt | cat b.txt | cat c.txt
출력x

=>원인 : 파이프라인기준 최우측 cat노드의 flag가 -1로 들어와서 분기문이 제대로 적용되지 않았다.
=>해결법
	지금 트리노드의 flag라벨링이 잘 되지 않은 것 같은데,,,
	그냥 트리 전체를 순회하면서 라벨링하는 함수를 내가 직접 만들어도 될 것 같다.
	값은 이미 들어있기때문에...ㅎ
	-1 -2 -3 -4를 >,>>,<,<<에 해당하는 리다이렉션,
	0은 명령어
	1은 파이프라인,으로 라벨링하면 좋을 듯?

## 3 exec오류날때 팁[처리완료]
exec류의 함수를 호출할때 arg, env를 인자로 넣어준다.
arg, env같은 이중포인터들은 마지막 포인터에 널을 포함시켜주어야 에러가 나지 않는다.
정확한 원인은 알 수 없지만 실행인자와 환경변수를 끝까지 읽어야 하는데 끝을 표시해주지않아서
무한루프를 도는 것이 아닐까 생각한다.

## 4 프롬프트창에 이전 입력의 결과가 들어온다.[처리완료]
부모프로세스가 자식프로세스를 기다리고 있나요? ㅎㅎ

## 5 export와 env를 인자없이 쓸 때의 차이점

export
- 환경변수를 key값기준으로 정렬하여 출력한다.
- declare -x A="B" 꼴로 출력한다.
- 환경변수 "_"에 대해서는 출력하지 않는다.
- value값이 없는 환경변수에 대해서 declare -x y 꼴로 출력한다.

env
- 환경변수의 value값이 없으면 출력하지 않는다.

## 6 export로 환경변수를 등록할때 예외규칙

- export a를 수행시 key는 등록되지만 value는 null이 저장된다.
- export a=를 수행시 key등록, value에 "" 빈문자열이 저장된다.


==============================================================
# 종료상태

쉘상에서 exit [0~256] 을 통해 쉘을 종료시킬 수 있다.
>exit     =>exit 가 실행되기 이전에 가장 마지막으로 수행됐던 명령어의 종료 상태를 반환

>exit 0 =>정상종료를 의미
>exit 1~256 =>각 인자에 따른 종료상태를 가지게 된다.

$? 는 가장 최근 명령어의 종료 상태를 나타냅니다.

## $?를 구현하려면...

- 직접만든 빌트인함수의 경우 각 경우에 따라 exit(arg)를 해주고 arg를 전역변수나 환경변수에 저장해준다.

- errono에 접근하는건 어떨까...!
그럼 $?를 적절한 errno로 치환해주는 작업은 어디서 해야하지?

# 3/30(화)

- 출력 리디렉션의 반복시, 맨 뒤에 파일로만 리디렉션하고 리디렉션은 무시했는데,
	중간에 거치는 파일을 생성하긴 해야하므로 약간 수정함.

- export a=b에서 a가 이미 존재한다면? 1. 무시 2. 덮어쓰기
- [export a] x, [export a=] o, => [구현완료]
- [export g=a=c] -> declare -x g="a=c" split말고 가장먼저찾은 '='기준으로 자르기

# 아직 구현해야 할 것.
- 시그널 및 종료상태 및 에러문 출력
	- minishell에서 minishell을 키면 시그널함수가 중첩되는 문제를 어떻게 해결?
- 각종 리다이렉션 및 파이프라인의 조합에 따른 테스트
	- 경우에 따라 트리의 구조가 바뀔 수 있다.

- heredoc(<<)

- $?
- pipeline의 결과가 이상할때가 있다 프롬프트가 출력이 안되는 경우... 왤까..?


# 보너스 및 희망사항
- 쉘프롬프트: 마지막 명령어 성공여부를 쉘프롬프트에 표시하면 어떨까?

# 투두리스트
- [터짐]빈 입력, 공백 입력
- minishell안에서 minishell 킨 상태로 [ctrl+ c] 하면 시그널처리가 2번됨. 1번만 수행되게 가능?
- $a를 입력했을때 Invalid Location 출력됨.(export a=b가 수행되었다고 가정)

- 따옴표 만들때 주의할 것. 작은따옴표로 둘러쌓인 토큰은 환경변수대입을 하지않고 그대로 출력해야함.
	export a=b
	echo '$a' => b가 아닌 $a가 출력되어야함.

- 이런 따옴표 케이스에 대해서 트리노드에 이런식으로 들어오면 내가 편함
echo 'hello''''world'
	bash출력> helloworld
	mini출력> 'hello''world'
command[0] = "echo"
command[1] = "hello"
command[2] = ""
command[3] = "world"

# gshim 투두리스트

- heredoc(<<) 구현
- $?에 마지막 실행된 명령어 종료상태 저장해두기.
빌트인함수들은 직접 변수에 값을 입력한다고 쳐도...
exec의 결과는 어디에 저장되며 이를 어떻게 변수에 입력할지..?
EXEC는 자식프로세스에서 수행된다. 자식이 종료될때까지 기다리고 있는 부모프로세스에서
wait다음행에 errno변수를 $?에 저장하면 될 것 같다.


- [처리완료]쉘에서 exit입력할때 실행인자도 처리해주기
- [처리완료]다양한 리다이렉션과 파이프라인 테스트하기
- [처리완료]리다이렉션 터지는거 있는데 잘 막기.
- [처리완료]export시 터지는거 막기

- [파이프라인오류]ls | grep m 시도시, 출력은 잘되는데.... 가끔 프롬프트가 먼저출력될 때가 있다. 부모프로세스가 자식프로세스를 기다리지 않기 때문일까?
 맞네...ㅋ[처리완료]

# heredoc을 어떻게 구현할까?

- 입력을 받는 것은 어렵지 않다. 받은 입력을 명령어 측에 어떻게 보내느냐가 관건이다.

1. 파이프를 생성하ㅏ여 heredoc의 결과를 파이프에 흘려보낸다?
- 기존의 미니쉘구조를 이용하여 구현가능하지만.. 파이프에 담을 수 있는 양의 한계가 있다.
그 한계를 벗어나는 양을 넣으면 더이상 write할 수 없다.

2. 임시파일을 생성하여 거기에 뱉어내고 그 파일을 리다이렉션!
- 실행시 임시파일을 open하여 생성하고 입력을 거기에 넣는다. 이름은 pid를 이용하면어떨까?
- 해당 파일 fd를 표준입력에 덮어쓴다.

- 2번 방식으로 구현완료! 그런데 파일을 작성할때 한번open, 읽기전용으로 다시open해줘야 동작한다. 왜지..?
- 기본적은 동작은 구현완료하였다. heredoc의 중첩시에는 어떻게 해야하지?

# $? - 프로세스의 종료상태를 알아내는법.

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=skout123&logNo=50133478563

```C
pid_t wait(int *status); // status에 자식프로세스 종료상태값이 저장된다.
```

- 자식프로세스의 종료상태는 어떤식으로 나타날까?

- 정상 종료시, status의 하위 8비트에 0, status의 상위 8비트에 exit함수 인수가 기록된다.
- 비정상 종료시, status의 하위비트에 프로세스 종료 시그널번호저장, 상위비트에 0.

* 종료상태 정보 매크로

WIFEXITED
WIFSIGNALED
WIFSTOPPED
WEXITSTATUS

종료상태넣을때 free선행시켜줘야함


# ㅗ답노트

- exit 값의 범위 ll, %256해서 나눈다.
음수의 경우에는 -10 => 246
256에서 뺀값이 된다.

exit 1 1 => too many argument error => exit 안됨.
exit 1one2  => numberic error
exit one  => numberic error
=> exit 됨.


#
bash-3.2$ cat << AAA << BBB
> hello
> BBB
> qwerrty
> AAA
> qwerrrrr
> BBB
qwerrrrr

- 명령어들은 대소문자 구분없이 실행된다??!@
	pwd
	PWd
	PWD
	pWD
	"pwd"
	'pwd'

- exec전에 malloc할당이 되어있는 녀석들을 free 해야할까?

cat < a a < b b < c << hi > x >> y

cat a b < a < b < c << hi > x >> y

heredoc
cat a b의 결과를 y에 넘긴다.
a,b,c파일이 존재해야 하며, x파일은 빈채로 생성된다.

ctrl + c, d, \ : bash에서와 같이 작동

## 오늘할일

- minishell 중첩 실행시 시그널처리 1번만 적용되게 하기.
=> 실행하는 파일이 미니쉘이면 시그널끄기. 미니쉘꺼지면 다시 시그널 키기.

- heredoc 에서의 시그널 처리[포기...ㅎ]
- cat (null) 에서의 시그널 처리

- cd에 인자가 너무 많으면??\


# 테스트

heredoc연속 -> ㄴㄴ ㄴ