# 3/19(토) 2:40

- 규진이코드에서 컴파일시 메모리릭 난다.(fsanitaze)
- >pwd, >quit (종료안됨) , >quit(종료됨) 의 동작을 이해할 수 없다.
	규진이와 점검하면서도 이상함을 느낀점이 있는데,,,
	원래라면 자식프로세스가 할일을 다하고 종료되고, 부모프로세스는 그때까지 대기해야 하는데
	자식프로세스가 할일을 끝내고 부모프로세스의 동작을 다시 수행하는 것 같다....
	exec이후에 자식프로세스가 살아서 printf를 수행하는 것을 보고 확신했다.
	자식프로세스가 왜 죽지 않는지 알아봐야 겠다.

- 빌트인 함수의 경우 규진이가 잘라놓은 env_list를 사용하기 용이하지만,
	그렇지 않은 함수를 사용할땐 env 포인터배열을 그대로 사용하는 게 유리하다.
	그렇다면 둘다 넘겨주어야 하나...?
	둘다 넘기던지 아니면 둘을 모두가진 구조체를 선언하여 관리할지 생각해봐야 겠다.

# 3/19(토) 2:55

- 일단 빌트인함수의 경우 exit을 시켜주지 않아 자식이 살아있어서 pwd, quit, quit이 가능했다.
	빌트인외 함수는 execve함수 밑으로는 실행되지 않는 것 같지만 규진이와 검사했을때
	execve행 이후의 free가 처리되는 것을 확인한 적이 있어 다시한번 체크해야겠다.
	그리고 계속되는 테스트에 죽지않고 살아있는 미니쉘 프로세스가 많아서 한번에 죽여버릴 스크립트를짰다
	ps | awk '{ print "kill -9", $1 }' | sh -v
	kill -9 `ps -ef | grep minishell | awk '{print $2}'`

- quit입력이외에 ctrl z 같은 시그널로 종료할 경우,,,, 프로세스가 죽지않아!

- leak 검사를 해보는데 leak이 너무 많다. 그리고 filepath는 free되지 않는 것 같다.

# 3/19(토) 3:12 자기 전 내일해야할 투두리스트

- 규진이 코드에서 leak을 잡고 내거에서도 filepath가 leak나지 않게 처리할 것.
- 쉘이 exit을 통해 꺼졌을때 다시 자동으로 켜줘야 한다고 들은것 같은데..
	그리고 애초에 ./minishell은 미니쉘 프로세스를 생성해주는 역할을 하니 그것도 메인에 넣어야함.
- env_list와 env를 둘다 사용할지 고르자.
- read_line -> parse_line -> execute 코드가독성이 너무 떨어짐.... 전체구조를 다시 고려해볼것.
- parse_line에서 strtok대신 사용할 수 있는 함수를 생각해볼것. split 시험본 버전으로하면 좋을듯.

# 3/19(토) 13:14

- 규진이 코드에서 릭나는건 모두 잡았다.
	1. linkedlist에서 addnode를 할때 추가하는 노드의 next필드를 NULL로 초기화하지않고 쓰레기값이 들어가서 다른 노드를 가리키는 것처럼 여겨진다.
	2. ft_strndup함수에서 복사를 수행하는 while문 조건식이 잘못되었다.

-

# 3/21(월) 17:34

- redirect함수에서 2가지를 구현한다.
	1. >, >>
	2. 두번 이상의 리다이렉트에 대응하기 위해, 현재 표준출력의 fd를 부모 프로세스에서 저장해둔다.
